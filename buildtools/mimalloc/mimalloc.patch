diff --git a/include/mimalloc-atomic.h b/include/mimalloc-atomic.h
index 7ad5da5..3029d97 100644
--- a/include/mimalloc-atomic.h
+++ b/include/mimalloc-atomic.h
@@ -325,7 +325,7 @@ static inline void mi_atomic_yield(void) {
 #elif defined(__wasi__)
 #include <sched.h>
 static inline void mi_atomic_yield(void) {
-  sched_yield();
+  // sched_yield();
 }
 #else
 #include <unistd.h>
diff --git a/src/alloc-override.c b/src/alloc-override.c
index e29cb4b..19f6822 100644
--- a/src/alloc-override.c
+++ b/src/alloc-override.c
@@ -256,7 +256,7 @@ int   reallocarr(void* p, size_t count, size_t size)    { return mi_reallocarr(p
 void* memalign(size_t alignment, size_t size)           { return mi_memalign(alignment, size); }
 void* _aligned_malloc(size_t alignment, size_t size)    { return mi_aligned_alloc(alignment, size); }
 
-#if defined(__GLIBC__) && defined(__linux__)
+#if defined(__GLIBC__) && defined(__linux__) || defined(__wasi__)
   // forward __libc interface (needed for glibc-based Linux distributions)
   void* __libc_malloc(size_t size)                      MI_FORWARD1(mi_malloc,size)
   void* __libc_calloc(size_t count, size_t size)        MI_FORWARD2(mi_calloc,count,size)
@@ -268,6 +268,7 @@ void* _aligned_malloc(size_t alignment, size_t size)    { return mi_aligned_allo
   void* __libc_pvalloc(size_t size)                     { return mi_pvalloc(size); }
   void* __libc_memalign(size_t alignment, size_t size)  { return mi_memalign(alignment,size); }
   int   __posix_memalign(void** p, size_t alignment, size_t size) { return mi_posix_memalign(p,alignment,size); }
+  void* aligned_alloc(size_t alignment, size_t size) { return mi_aligned_alloc(alignment, size); }
 #endif
 
 #ifdef __cplusplus
diff --git a/src/os.c b/src/os.c
index 72959d8..81e7276 100644
--- a/src/os.c
+++ b/src/os.c
@@ -70,6 +70,9 @@ terms of the MIT license. A copy of the license can be found in the file
 bool _mi_os_decommit(void* addr, size_t size, mi_stats_t* stats);
 bool _mi_os_commit(void* addr, size_t size, bool* is_zero, mi_stats_t* tld_stats);
 
+void* mi_tinygo_alloc(size_t size, size_t alignment);
+void mi_tinygo_free(void* addr);
+
 static void* mi_align_up_ptr(void* p, size_t alignment) {
   return (void*)_mi_align_up((uintptr_t)p, alignment);
 }
@@ -374,7 +377,7 @@ static bool mi_os_mem_free(void* addr, size_t size, bool was_committed, mi_stats
     _mi_warning_message("unable to release OS memory: error code 0x%x, addr: %p, size: %zu\n", errcode, addr, size);
   }
 #elif defined(MI_USE_SBRK) || defined(__wasi__)
-  err = false; // sbrk heap cannot be shrunk
+  mi_tinygo_free(addr);
 #else
   err = (munmap(addr, size) == -1);
   if (err) {
@@ -464,78 +467,7 @@ static void* mi_win_virtual_alloc(void* addr, size_t size, size_t try_alignment,
 -------------------------------------------------------------- */
 
 #elif defined(MI_USE_SBRK) || defined(__wasi__)
-#if defined(MI_USE_SBRK) 
-  static void* mi_memory_grow( size_t size ) {
-    void* p = sbrk(size);
-    if (p == (void*)(-1)) return NULL;
-    #if !defined(__wasi__) // on wasi this is always zero initialized already (?)
-    memset(p,0,size); 
-    #endif
-    return p;
-  }
-#elif defined(__wasi__)
-  static void* mi_memory_grow( size_t size ) {
-    size_t base = (size > 0 ? __builtin_wasm_memory_grow(0,_mi_divide_up(size, _mi_os_page_size()))
-                            : __builtin_wasm_memory_size(0));
-    if (base == SIZE_MAX) return NULL;     
-    return (void*)(base * _mi_os_page_size());    
-  }
-#endif
 
-#if defined(MI_USE_PTHREADS)
-static pthread_mutex_t mi_heap_grow_mutex = PTHREAD_MUTEX_INITIALIZER;
-#endif
-
-static void* mi_heap_grow(size_t size, size_t try_alignment) {
-  void* p = NULL;
-  if (try_alignment <= 1) {
-    // `sbrk` is not thread safe in general so try to protect it (we could skip this on WASM but leave it in for now)
-    #if defined(MI_USE_PTHREADS) 
-    pthread_mutex_lock(&mi_heap_grow_mutex);
-    #endif
-    p = mi_memory_grow(size);
-    #if defined(MI_USE_PTHREADS)
-    pthread_mutex_unlock(&mi_heap_grow_mutex);
-    #endif
-  }
-  else {
-    void* base = NULL;
-    size_t alloc_size = 0;
-    // to allocate aligned use a lock to try to avoid thread interaction
-    // between getting the current size and actual allocation
-    // (also, `sbrk` is not thread safe in general)
-    #if defined(MI_USE_PTHREADS)
-    pthread_mutex_lock(&mi_heap_grow_mutex);
-    #endif
-    {
-      void* current = mi_memory_grow(0);  // get current size
-      if (current != NULL) {
-        void* aligned_current = mi_align_up_ptr(current, try_alignment);  // and align from there to minimize wasted space
-        alloc_size = _mi_align_up( ((uint8_t*)aligned_current - (uint8_t*)current) + size, _mi_os_page_size());
-        base = mi_memory_grow(alloc_size);        
-      }
-    }
-    #if defined(MI_USE_PTHREADS)
-    pthread_mutex_unlock(&mi_heap_grow_mutex);
-    #endif
-    if (base != NULL) {
-      p = mi_align_up_ptr(base, try_alignment);
-      if ((uint8_t*)p + size > (uint8_t*)base + alloc_size) {
-        // another thread used wasm_memory_grow/sbrk in-between and we do not have enough
-        // space after alignment. Give up (and waste the space as we cannot shrink :-( )
-        // (in `mi_os_mem_alloc_aligned` this will fall back to overallocation to align)
-        p = NULL;
-      }
-    }
-  }
-  if (p == NULL) {
-    _mi_warning_message("unable to allocate sbrk/wasm_memory_grow OS memory (%zu bytes, %zu alignment)\n", size, try_alignment);    
-    errno = ENOMEM;
-    return NULL;
-  }
-  mi_assert_internal( try_alignment == 0 || (uintptr_t)p % try_alignment == 0 );
-  return p;
-}
 
 /* -----------------------------------------------------------
   Raw allocation on Unix's (mmap)
@@ -726,7 +658,7 @@ static void* mi_os_mem_alloc(size_t size, size_t try_alignment, bool commit, boo
   #elif defined(MI_USE_SBRK) || defined(__wasi__)
     MI_UNUSED(allow_large);
     *is_large = false;
-    p = mi_heap_grow(size, try_alignment);
+    p = mi_tinygo_alloc(size, try_alignment);
   #else
     int protect_flags = (commit ? (PROT_WRITE | PROT_READ) : PROT_NONE);
     p = mi_unix_mmap(NULL, size, try_alignment, protect_flags, false, allow_large, is_large);
